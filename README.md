# Основные операции С++
После рассмотрения переменных и их типов, мы знаем что они служат как индетификатор для ссылки на область памяти для того чтобы сосчитать значение с памяти или записать(в случае если переменная не константная). Ну все это классно, но язык только выполняя такие опреции был бы не полон, т.е. необходимы некий механизмы для малинипуляции(обработки) этих данных(переменных). Для этого в языке С++ есть огромный набор операций для работы с данными. Их называют операторы и они обозначаються разными специальными символами(+, -, / и т.д.). С помощью опреаторов мы можем выполнять математические опреации, логические, битовые. Оператор он оперирует операндами(переменные, литералы).
Различают следующие виды операторов:
- Унарный
- Бинарный
- Тернарный(будем рассматривать в разделе условные операторы)

Бинарный опреатор, работает с двумя операндами, и  имеет следующий вид 

```cpp
операнд оператор операнд;
```

Унарный оператор может стоять как перед операндом, так и после

```cpp
операнд оператор;
оператор операнд;
```

Хотел бы уточнить важную деталь, некоторые операторы могут нести разный смысл в зависимости от контекста(т.е. может применяться как бинарный так и унарный). Например оператор &, если его использовать как бинарный оператор то он применяеться для бинарной(двоичной) арифметики, а если его использовать как унарный оператор то он рассматриваеться как оператор взятия адресса у переменной.
## Оператор присвоение
Мы с Вами уже рассматривали оператор присвоение, когда рассматривали типы данных. Но сейчас рассмотрим его подробней.
Простыми словами оператор присвоение это присвоение значение переменной. Оператор присвоение имеет следующий вид:
```cpp
// операнд = операнд
```
Как видим с описания оператор присвоение это бинарный оператор. Левый операнд оператора присвоения являеться переменной, а правая часть должна быть значением, которое мы хотим присвоить переменной. Под переменной понимаем участок памяти куда можно что то записать, под правой частью понимаем значение, при этом значением может быть как переменная(считать данные лежащие в этой переменной), так и литерал.
Примеры
```cpp
#include <iostream>

int main(int argc, char const *argv[]) {
  // обьявляем переменную(переманная неявно инициализируеться неопределенным значением)
  unsigned value;
  // присваеваем переменной value значение 30
  value = 30;
  std::cout << value << std::endl;

  /*
    другой пример использования оператора присвоения это использовать его при инициализации переменой,
    т.е. совместить обьявление с инициализацией
  */ 
  unsigned value2 = 40;
  std::cout << value2 << std::endl;

  // присвоение, но в качестве значения есть не литерал, а значение переменной, в этом случае старое значение переменной затреться
  value = value2;
  std::cout << value << std::endl;
  
  /*
    результат операции присвоение может быть также значением
    в примере ниже все три переменные будут иметь одно и тоже знеачение, т.е.
    переменная value3 проинициализируеться значением результата присвоение перменной value2 значения переменой value
    В этом примере стоит заметить что присвоение всегда выполняеться справа на лево
  */
  unsigned int value3 = value2 = value; // тоже самое unsigned int value3 = (value2 = value);
  std::cout << value3 << " " << value2 << " " << value);

  unsigned char value4 = 90;
  // неявное преобразование типа char > unsigned int
  value3 = value4;

  /*
   при попытке выполнить следующий оператор присвоения, мы получим ошибку компиляции, что
   "lvalue required as left operand of assignment" смысл которой то что в левой части должна быть переменная,
   а в правой выражение
  */ 
  // 6 = value3;
  // 5 = 10;

  return 0;
}
```
С примера выше видно можна выстраивать цепочки присвоения. Опреатор присвоение есть (возможно) строгий порядок выполнения, т.е. справа на лево, и это даже видно из цепочки присвоения(но и это и очевидно, нам надо что то взять, в данном случае значения что бы потом его положить в переменную)
Оператор присвоение считаеться коректным если ему присваеться значение соответсвующего типа или значение которое неявно можно приобразовать к присваемому типу.
Если попробовать расскоментировать последние строки кода, то мы увидем странное сообщение компилятора в котором говорится о каком то lvalue. Это связано с тем что каждое выражение имеет тип и принадлежит так называемой числовой категории(value category). Числовая категория это базовые правила, в соответствии компилятор должен следовать, когда он создает, копирует, или перемещает временные обьекты на протяжении вычесления выражения. Или если очень упрощенно, то говориться что слева от оператора присвоения всегда должна быть переменная которую можно изменить(пример с константными переменными).

Но есть одно большое но, при использованни оператора присвоения. А что если мы переменной с меньшей размерностью присвоим переменную с большей размерностью(т.е. если присваиваемая переменная не может вместить значение которое мы присваиваем), в этом случае будет переполнение. Или случай если мы присваиваем например целочисленной переменной, переменную которая имеет вещественный тип, то в этом случае будет срезка, т.е. потеря дробной части(иногда это ожидаемое поведение, если нам не нужна дробная часть).
Давайте пример
```cpp

#include <iostream>
#include <limits>

int main(int argc, const char** argv) {
  // получаем максимальное значение для типа int
  int value = std::numeric_limits<int>::max();
  std::cout << value << std::endl;
  // в этом случае значение переменной value больше чем может вместить переменная value1
  // в итоге мы получим переполнение
  short value1 = value;
  std::cout << value1 << std::endl;

  double value2 = 123.123;
  std::cout << value2 << std::endl;
  int value3 = value2;
  std::cout << value3 << std::endl;
  return 0;
}
``` 

### Неявное преобразование типов
Выше в примере мы расммотрели случай с переполнением и срезкой, но этому случаю есть и другое распостранненое название как неявное преобразование типов. Что это? Давайте сразу с примера
```cpp
#include <iostream>
#include <limits>

int main(int argc, const char** argv) {
  // получаем максимальное значение для типа int
  int value = 100;
  std::cout << value << std::endl;
  // в этом случае происходит неявное преобразование типа,
  // т.е. компилятор преобразует перменную value в которой тип int
  // в тип short (переменная value1)
  short value1 = value;
  std::cout << value1 << std::endl;

  // в этом случае кроме срезки происходит также неявное преобразование типа double в тип int 
  double value2 = 123.123;
  std::cout << value2 << std::endl;
  int value3 = value2;
  std::cout << value3 << std::endl;

  // также случай неявного преобразования типа char в тип double
  char ch = 'A';
  double value4 = ch;
  // на экране увидем значение 65
  std::cout << value4 << std::endl;


  // также происходит неяное преобразования int в тип bool
  bool value5 = 1;
  std::cout << std::boolalpha;
  std::cout << value5 << std::endl;

  bool value6 = 0;
  std::cout << std::boolalpha;
  std::cout << value6 << std::endl;
  return 0;
}
```
Как видно с примера  неяное преобразования это способ компилятором представить одно значение в формате другого значения(присваемого). Стоит заметить что если у нас есть выражение в котором присутвуют переменные с разными типами, то компилятор будет максимально пытаться скомпилировать ваш код выполнив неявное преобразоване типов. Но это вличет разные последствия, как пример если мы пытаемся типу с меньшим размером присвоить значение тип которого больше по размеру. Если компилятор не находит подходящего способа преобразования, то компилятор выдает ошибку, и компиляция прекращаеться.
Неявное преобразование может привести к потери данных, например если преобразовывать вещественный тип к целому, то мы потеряем дробную часть (хотя такой подход применим в некоторых случаях когда явно необходимо отбросить дробную часть). Также часто встречающаяся ошибка преобразования знаковый-беззнаковое преобразование. Проблема неявного преобразования в том что компилятор не предупреждает о неявном преобразовании знаковых в незнаковый.
### Явное преобразование типов(Explicit conversions)
В С++ также есть другое понятие это явное преобразование типа. В случае когда мы явно хотим преобразовать типы, например когда компилятор выдает предупреждение, или как в примере вычесление вещественого числа мы хотим явно показать читающего нащ код что мы знаем о потере дробной части, то нам необходимо явное преобразование. Явным преобразованием мы говорим компилятору и читающего наш код что мы знаем что делаем, и он умывает руки. Есть два способа указания явного преобразования:
 - С подход (стиль)
 - С++ подход (стиль)
### C style casting
Это наследие старого доброго С. Простыми словами С кастинг типов очень плох во многих контекстах, в нашем случае его плохо распознать при чтении кода. Его плюсы и минусы мы будем использовать по мере изучения курса. Мой совет избегать С casting.
### C++ style casting
С++ стиль кастинг являеться более предпочтитлен, так как он более безовасный, и его проще найти в коде чем С casting из-за его синтаксиса.
В данном разделе мы пока ознакомимся только `static_cast`, но на протяжении мы будем знакомиться с другими типами С++ casting.
Простым словом `static_cast` делает практически то что делает неявно компилятор (приведение типов).
Пример
```cpp
  int static_style_cast = 1000;
  // явно преобразовываем переменную типа int в double 
  double double_cast_ = static_cast<double>(static_style_cast);
  std::cout << double_cast_ << std::endl;
```
### Арифметические операции
Так как мы в начале рассматриваем только встроенные типы, то будем рассматривать только арифметические операции, по их прямому назначению, т.е. в С++ арифметические операции прямо означаю то что и в матиматическом понимании. Дальше мы будем рассматривать указатели так вот некоторые арифметические операции, ведут себя иначе. 
Выделяют пять арифметических операций:
+ оператор сложения
- оператор вычитания
* оператор умножения
/ оператор деления
% остаток от целочисленого деления

Оператор +, он бывает как бинарный так и унарный. И имеет следующий вид:
```cpp
операнд + операнд // бинарный

+операнд // бинарный

```
```cpp
#include <cstdio>
#include <cstdint>

int main(int argc, char const *argv[]) {
  // объявляем переменную
  uint16_t value;
  // сложение двух rvalue
  value = 30 + 50;
  std::cout << value << std::endl;

  /*
   совмещение объявления и инициализации с использование оператора +
   тут используеться микс, т.е. в качестве операндов может быть как lvalue + rvalue
   или наоборот rvalue + lvalue
  */
  uint16_t value2 = value + 90;
  std::cout << value2 << std::endl;

  // используеться как lvalue + lvalue
  uint16_t value3 = value +  value2;
  std::cout << value3 << std::endl;

  // пример где в качестве операнда может быть значение результата присвоения
  uint16_t value4 = 200 + (value = value3);
  std::cout << value4 << std::endl;

  // будет ошибка компиляции, попытка rvalue(временной переменной) присвоить значение 
  // (value + 300) = value4;

  /*
   ошибка, так как оператор +, в бинарном виде должен иметь два операнда, т.е. суть в том что компилятор ожидает полное выражение
  */
  // uint16_t value5 = value4 + ;

  // Есть унарный + но смысла я в нем невижу, к сожалению, его идея это добавить знак + к значению, как в матиматике
  // явно указываем что число у нас положительное, применяеться к rvalue
  uint16_t value5 = +10;
  std::cout << value5 << std::endl;
  
  // явно указываем что число у нас положительное, применяеться к lvalue
  value4 = +value5;
  std::cout << value4 << std::endl;

  // ошибка, такая как и с бинарный оператором +
  // +value5 = value4;

  // два литерала double
  double value6 = 1.25 + 3.25;
  std::cout << value6 << std::endl;

  // также можно использовать суфиксы
  value6 = 1.f + 1.30;
  std::cout << value6 << std::endl;

  // результат будет  вещественное число double > int
  value6 = 1000 + 1.40;
  std::cout << value6 << std::endl;

  // 170 + 220 = 390, т.е вместо 390, увидем 134, это пример переполнения
  uint8_t value7 = value2 + 220;
  std::cout << value7 << std::endl;

  // но этого можно избежать используя вывод типов, получим 390
  auto value8 = value2 + 220;
  std::cout << value8 << std::endl;

  // ну или используя унифицированную инициализацию, получим предупреждения компиляции сужающие преобразование
  uint8_t value9 {value2 + 220};
  std::cout << value9 << std::endl;

  return 0;

}
```
Стоит сделать маленькую ремарку относительно оператора +, это то что он дает временное выражение которое должно находиться только справа от оператора =.
Какие могут быть проблемы связанные с оператором +? самой большой может быть, это когда значение выражение в правой части больше по типу чем переменная в левой части.
Также важно понимать что при выполнении арифметической операции, результат вычесления выражение продвигаеться в сторону большего типа, например поумолчанию все литералы имееют тип int, и если сумма двох литералов больше типа int он продвигаеться(неявное преобразование) к типу большего размера(например если на некоторой системе тип int 32, то продвигаеться к 64). И также если переменная в качестве операнда иммеет больше тип чем другая переменная или литерал, то результат продвигаеться к типу переменной большего размера.
Оператор +, так же само справедлив и для вещественной арифметики, так же само справедливо и продвижение(неявное преобразование) типа. Также необходимо не забывать о срезке(т.е. потерю дробной части).
Для избежания, возможных срезок или сужающих преобразований (narrowing conversion), применяйте ключевое слово auto (в этом случае компилятор сам выведит тип переменной).

Оператор - также как и оператор + бывает бинарный и унарный. И имеет следующий вид:
```cpp
операнд - операнд // бинарный

-операнд // бинарный

```
Он по семантике идентичен также как и оператор +, только вычитает одно значение от другого(вообщем как и в математике). Также проблемы присущие опреатору +, в плане переполнения, или срезок, присущи и оператору -
```cpp
void work_with_operator_minus() {
  // разница в том что результатом выражения надо делать знаковую переменную, т.к. результат может быть отрицательное число

  int32_t value1 = 100 - 70;
    std::cout << value1 << std::endl;

  int32_t value2 = value1 - 70;
    std::cout << value2 << std::endl;
  uint32_t value3 = 100;
  // иногда логически не коректен т.к. размер безнакового больше чем знакового и мы можем получить переполнения
  int32_t value4 = value3 + value2;
  std::cout << value4 << std::endl;

  // получим переполнение
  value4 = std::numeric_limits<uint32_t>::max() - 100;
  std::cout << value4 << std::endl;

  /*
    тут мы инвертируем знак, в отличие от унарного +, он имеет смысл
    в смене знака надо быть тоже осторожным, если мы поменяем с бещнакового на знаковое получим переполнение
  */
  int32_t value5 = -value2;
  std::cout << value5 << std::endl;
}
```
Одно значительно отличие есть в опреаторе -, это применения его как унарного, он инвертирует знак оператора на обратный.

Оператор /, по семантике идентичен также как и в математике. Оператор деление может быть только бинарным, т.е. применяться только к двум операндам.
```cpp
операнд / операнд
```
Проблемы сужения, или срезки присущи так же как и для других арифметических операторов. Но есть одно важное замечание, в отличие от матиматики, в которой деление дает всегда дробное число, то в языке С++ если два операнда есть целочисленными то мы получим целочисленное деление и результат будет целое число, т.е. мы потеряем дробную часть.
```cpp
void work_with_divide() {
  // получим целое число без дробной части
  double value1 = 10 / 20;
  std::cout << "value1 = " << value1 << std::endl;
  // получим число с дробной частью
  // или можно использовать явное преобразование к типу
  value1 = 10.f / 20; // value1 = (double)10 / 20; или value1 = static_cast<float>(10) / 20;
  std::cout << "value1 = " <<  value1 << std::endl;
  
  int8_t value2 = 100;
  // полученем целое число
  value1 = value2 / 90;
  std::cout << "value1 = " <<  value1 << std::endl;
  value1 = value2 / (double)90; // double(value2) / 90;
  std::cout << "value1 = " << value1 << std::endl;

  // может кинуть исключительную ситуацию
  //int value3 = value2 / 0;
  // получим бесконечность inf
  double value3 = static_cast<double>(value2) / 0;
  std::cout << "value3 = " << value3 << std::endl;

  // это есть не число
  value3 = 0.f / 0;
  std::cout << "value3 = " << value3 << std::endl;
}
```
С примера выше видно, то чтобы получить дробное число, в случае если у нас два операнда это целочисленные переменные, то один из операндов необходимо явно преобразовать к вещественному типу данных. 
С оператором деления есть два момента:
Вообще деление на ноль по стандарту это неопределенное поведение, т.е. компилятор вправе сам решать что ему делать в этой ситуации
1. При делении на ноль с целочисленными значениеями, то происходит прекращение работы нашего приложения.
2. При делении вещественных чисел, взможен другой исход
  - число на ноль, это бесконечность, специальное число inf. Согласно википедии бесконечность это более близкое/правильноее      
    приближение к числу. Получить бесконечность можно при переполнении и при делении ненулевого числа на ноль.
  - не число, nan, если во время их выполнения вычисления произошла ошибка.
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB

По ссылке выше есть описание что такое не число, и что такое бесконечность. При некоторых алгоритмах, когда нужно какое то начальное значение часто испольуют бесконечность, например для поиска кратчайшего пути в графе
https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B

Оператор *, по семантике идентичен также как и в математике. Оператор деление может быть только бинарным, т.е. применяться только к двум операндам.
```cpp
операнд * операнд
```
Проблемы сужения, или срезки присущи так же как и для других арифметических операторов. В нем отсутсвуют проблемы присущие оператору деления, например двух целых чисел, правила продвижения типов такие же как и оператора + и оператора -
```cpp
void work_with_multiplication() {
  // при умножении можно больше получить возможности переполнения
  int32_t value1 = 100 * 2;
  std::cout << value1 << std::endl;

  int32_t value2 = value1 * 30;
  std::cout << value2 << std::endl;

  // получим переполнение, возмоно компилятор выдаст предупреждение
  uint8_t value3 = 20 * 140;
  std::cout << value3 << std::endl;

  // также получим переполнение
  value3 = value1 * 140;
  std::cout << value3 << std::endl;
}
```
### Смешанные выражения
После изучение всех, почти всех, арифметических операций, их можно смешивать в одно выражение. Было бы глупо выполнять все эти операции последовательно.
Проблемы срезки, переполнеия также присущи как и для одиночных операций. Правила продвижения типа также присутствуют.
Но перед тем как приступить к примерам со смешанными выражениями, я хотел бы описать в двух словах что такое приоритет операции. 
Как и в математике, в программировании присущи приоритеты, например сначало выполняеться умножение а потом сложение, это понятно. Но как быть например если в одном выражении есть и умножить и разделить. Например:
```cpp
void mixed_expression() {
  // тут понятно, как и в матиматике сначало умножение а потом результат складываться с числом 20
  uint32_t value1 = 20 + 30 * 50;
  std::cout << value1 << std::endl;
  // все зависит от того как компилятор будет выполнять выражение слева направо или справа на лево
  double value2 = 20.f  / 30 + 25 * 10;
  std::cout << value2 << std::endl;

  /*
   тут будет неопределенная последовательность вычесления
   т.е. что выполнятися сначало value2 * value2 или value2 / value1 или value1 / value1
   если посмотреть асемблерный код под х86-64 gcc 8.2, то порядок будет
   слева на право (в большинстве реализациях так и есть)
  */
  double value3 = value2 * value2 / value1 / value1;
  std::cout << value3 << std::endl;
  /*
   чтобы не было такой путаницы применяют оператор (), т.е им мы укащываем что должно быть первым выполняться
   сначало поделим value1 на value1, потом помножим value2 на value2 и потом результат двох выражений поделим между собой
  */
  value3 = (value2 * value2) / (value1 / value1);
  std::cout << value3 << std::endl;
}
```
Как видим из примера в некоторых выражения используеться приоритет опрерации
https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%B2_C_%D0%B8_C%2B%2B
Т.е. в зависимости от приоритета компилятор выполнит ту операцию преоритет которой выше чем другие операции, например в примере выше  переменная `value1`, сначало выполнилось умножение, а потом сложение, т.к. оператор умножение выше в приоритетности чем оператор сложение. Иногда если приоритетность операторов равна, как в примере вначале с переменой `value3`, то компилятор вправе сам поступать что вычеслять первым. Ну для того что бы избавиться от непределенности(поведения компилятора), используют как и в матиматике оператор круглые скобочки, для того чтобы выделить приоритетность оператора как для в примере для переменной `value3`.

### Временная переменная
В соответсвии с википедией, мне больше всего понравилось его определение. Вре́менные объекты(переменные) — в C++ объекты(переменные), которые компилятор создаёт автоматически по ходу вычисления выражений(например сложение, умножения). Такие объекты не имеют имени и уничтожаются сразу же, как только в них исчезает потребность.
Мы будем часто сталкиваться с понятием временных переменных. Мы уже получали временные переменные, когда мы работали с арифметическими операторами, т.е. их результат есть временная переменная которая записываеться в переменную которая стоит в левой части. Из этого следут что мы получаем временное значение котрое живет до окончание инструкции, т.е. до `;`.
Вторым примером временного объекта, являеться приведение типа.
```cpp
#include <iostream>

int main(int argc, char const *argv[]) {
    float float_value = 1.45;
    // преобразование типов также приводит к созданию временного объекта
    int int_value = static_cast<int>(float_value);
    std::cout << int_value << std::endl;

    int first_value = 10;
    int second_value = 40;
    // результат выражения first_value + second_value даст временную переменную, которая потом будет записанна в переменную
    auto new_value = first_value + second_value;
    std::cout << new_value << std::endl;

    return 0;
}

```

### Rvalue и Lvalue
Эти определения очень сложны, мы к ним вернемся когда будем рассматривать ссылки, указатели и т.д.
Если просто то lvalue это может быть перменная, т.е. lvalue характеризуеться как выражение чей адресс мы можем взять(с переменной связана область памяти).
Rvalue это выражение в котром нельзя взять его адресс(например адресс литрала 45, мы взять не может т.к. он не храниться в памяти). Примеры rvalue это литерал(это не переменная), результат вычисления выражения.

```cpp
#include <iostream>

int main(int argc, char const *argv[]) {
    // переменная а есть lvalue т.к. с ней связан адресс в памяти, литерал 30 это rvalue
    int a = 30;

    /* 
     в данном случае переменная а и b есть lvalue
    */
    int b = a;

    // ошибка компиляции, т.к. и не логично
    // 7 это литерал(rvalue), а b это lvalue
    // 7 = b;

    // ошибка компиляции, т.к.
    // выражение (b + a) есть временным(или промежуточным)(rvalue) 
    (b + a) = 90;
    return 0;
}
```

### Составной оператор присвоение
В С++ есть так называемые составные операторы. Т.е. все выше фарифметические операции можно записать в форме составного оператора. Идея составного оператора, очень проста, вычеслить выражение находящее справа от оператора присвоение, дальше выполнить составную операцию, например сложение, с переменой находящеся слева, и результат записать в переменную.
Составной оператор это сокращенная форма вида
```
x += 10;
x = x + 10;
// и тоже самое для других

// раскроеться так x = x * (20 + 30);
x *= 2 + 30;
``` 

```cpp
#include <iostream>

int main(int argc, char const *argv[])
{
    uint64_t value = 0;
    std::cout << value << std::endl;
    // составной оператор это сокращенная форма value = value + 3;
    value += 3;
    std::cout << value << std::endl;
    value += 5;
    std::cout << value << std::endl;
    value += 2;
    std::cout << value << std::endl;

    // имеет вид value = value * (1 + 2); результат будет на экране 30
    value *= 1 + 2;
    std::cout << value << std::endl;

    value /= 3;
    std::cout << value << std::endl;

    value -= 5;
    std::cout << value << std::endl;
    return 0;
}
```
Составной оператор вида `x += 3` и `x = x + 3` компилятором генерируют одну и туже инструкцию. В коде это просто удобная форма записи, но компилятором это одно и таже инструкция, это надо понимать.

### Инкремент и декремент
Инкримент и декремент есть унарная операция. Простыми словами это увеличение или уменьшение на единицу переменной. Это сокращенная форма записи следующего кода
```cpp
++x
тоже что и
x = x + 1
x += 1;
```
Компилятор в наше время сейчас для трех приведеных выше операций один и тот же код.
Инкримент и декримент бывают суфиксные(пост) и префиксные. Суть их одна и таже, увеличить/уменьшить переменную на единицу, но есть небольшие отличия, которые мы рассмотрим ниже на примерах.

```
// пре инкримент
++x;
// пост инкримент(суфиксный)
x++;
// пре декремент
--x;
// пост декремент(суфиксный)
x--;
```
Обе формы как декремента так и инкримента должны быть применены только к перменным(lvalue).
Смысл пре и пост следующий:
- Пре операция увеличивает непосредственно переменную на единицу и возвращает сразу результат
```cpp
++x;
x = x + 1;

--x;
x = x - 1;
```
- Пост операция, сначало мы читаем значение с переменной ложим его во пременную переменную, и потом увеличиваем переменную на 1, а в выражении будет использоваться старое значение переменной
```cpp
auto y = 10 + x++;

то же что и
auto tmp = x;
x = x + 1;
auto y = 10 + tmp;
```
Т.е. видим что при пост операции есть дополнительная переменная, т.е она возвращает временное выражение(предедущее значение переменной), в то время как пре возращает уже изменненое значение переменной 

```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
  size_t value = 0;
  std::cout << value << std::endl;
  ++value;
  // напечатает 1
  std::cout << value << std::endl;
  // напечатает 2
  std::cout << ++value << std::endl;
  // напечатает 2
  std::cout << value << std::endl;
  // напечатает 2
  std::cout << value++ << std::endl;
  // напечатает 3
  std::cout << value << std::endl;
  // напечатает 2
  std::cout << --value << std::endl;
  // напечатает 2
  std::cout << value-- << std::endl;

  // напечатает 1
  std::cout << value << std::endl;

  // получим предупреждение компилятора operation on ‘value’ may be undefined, то есть порядок вычисления вырадений может быть разным
  auto value2 = (++value * 2) + (value++ + 2);

  std::cout << value2 << std::endl;

  return 0;
}

```

### Операции отношения
Оперция отношения служат для того чтобы сравнить два операнда на эквивалентность, больше или меньше. Результатом этих операций есть булевое выражение true или false(истина или ложь). Чаще эти операции применяються в условных операторах или циклах (которые мы будем рассмартривать в следующих разделах). Но можно присваивать и переменным, для этого используют типа данных bool.
Операции отношения есть бинарными операциями, т.е. в сравнении участвуют два операнда.
Сужествуют следующие операции отношения
```
== равно
!= неравно
> больше
< меньше
>= больше либо равно
<= меньше либо равно
```
```cpp
#include <iostream>
#include <iomanip>

int main(int argc, char const *argv[]) {
    bool value = 10 > 5;
    std::cout << std::boolalpha;
    std::cout << value << std::endl;

    value = 10 < 5;
    std::cout << value << std::endl;

    value = 10 == 10;
    std::cout << value << std::endl;

    value = 10 == 10;
    std::cout << value << std::endl;

    value = 10 >= 9;
    std::cout << value << std::endl;

    value = 10 <= 20;
    std::cout << value << std::endl;

    value = 10 != 20;
    std::cout << value << std::endl;
    return 0;
}
``` 
## Логичееские операции
Операторы отношения они проверяют только одно условие, но необходимы операторы для объединения нескольких условий. Для этого использую логические операции:
```
&& - логическое и, возвращает true только если оба операнда равны true
|| - логическое или, возвращает true, если один из операндов равен true
```
Перечисленые операторы являються бинарными

```
! - логическое отрицание, т.е. делает обратное, если выражение равно true, то отрицание даст false или наоборот
```

```cpp
#include <iostream>
#include <iomanip>

int main(int argc, char const *argv[]) {
    std::cout << std::boolalpha;

    int a = 41;
    // проверка диапазона (20, 40] 
    bool is_access = a > 20 && a <= 40;
    std::cout << is_access << std::endl;

    is_access = a == 20 || a == 41;
    std::cout << is_access << std::endl;

    is_access = !(a == 20 || a == 41);
    std::cout << is_access << std::endl;

    // если применить к выражению закон де моргана
    is_access = !(a == 20) && !(a == 41);
    std::cout << is_access << std::endl;

    bool flag = false;

    a = 101;

    is_access = a > 100 && flag;

    std::cout << is_access << std::endl;

    is_access = !(a > 100 && flag);
    std::cout << is_access << std::endl;
    // выражение выше соответствует закону де моргана
    is_access = !(a > 100) || !flag;
    std::cout << is_access << std::endl;

    auto value = 1;
    is_access = value != 0 && a > 100;
    std::cout << is_access << std::endl;

    // в силу того что неявно в С++ целый тип может преобразовываться в bool
    is_access = value && a > 100;
    std::cout << is_access << std::endl;
    // по правилам перобразования все что не 0 это true
    value = 0;
    // такую конструкцию !value, но этим просто означает что проверяют на ноль
    is_access = !value && a > 100;
    std::cout << is_access << std::endl;
    
    // в выражения может присутсвовать смешаные логические операторы
    is_access = (a > 101 && a < 200) || !value;
    std::cout << is_access << std::endl;
    return 0;
}
```
Важным замечание, в приведеным примере выше, бинарные логические операторы, выполняються со следующим условием:
- В операторе && если первый операнд равен false, то второй операнд выполнятся не будет (так все условие станет ложним)
- В операторе || если перавый оператор ранвен true, то второй оператор проверяться не будет (так как все условие будет истиным)
Это очень полезно при проверке многих условий

### Битовые операции
Ну как звучит из названия битовые операции служат для работы с битовой арифметикой. Различают следующие битовые операции:
- `&` порязрядно битовое умножение, истино только если оба бита истины
- `|` поразрядное битовое сложение, истино если хоть один из битов истиный
- `~` битовое отрицание, т.е инверсия всех битов
- `>>` сдвиг вправо на укащаное количесвто битов
- `>>` сдвиг влево на укащаное количесвто битов
- `^` исключающее или, т.е. равно истине если один из опрендов истино, а другой ложь(имеет многое применение)
```cpp
#include <iostream>

int main(int argc, char const *argv[]) {
   uint16_t value = 0b000'000'000'000'010'0;
   std::cout << value << std::endl;
   uint16_t value2 = 0b000'000'000'000'000'1;
   std::cout << value << std::endl;
   // Пример установки бита
   /*
     000'000'000'000'010'0
                           |
     000'000'000'000'000'1
     ---------------------
     000'000'000'000'010'1 == 5 --> 2^0 + 2^2
   */ 
   std::cout << (value | value2) << std::endl;
   
   value2 = 0b111'111'111'111'101'1;
   // пример сбросить бит
   /*
     000'000'000'000'010'0
                           &
     111'111'111'111'101'1
     ---------------------
     000'000'000'000'000'0
   */ 
   std::cout << (value & value2) << std::endl;

   // инверсия битов, таки способом можно получить максимальное
   /*
     ~ 000'000'000'000'010'0
     ---------------------
       111'111'111'111'101'1 = 
   */

   value = ~value;
   std::cout << value << std::endl;

   // должны получить максимальное значение 16 битного разрадного числа 
   value = 0;
   value = ~value; 

   std::cout << value << " " <<  std::numeric_limits<uint16_t>::max() << std::endl;
   
   // должны получить максимальное знакового 16 битного числа
   std::bitset<8> b(126);

   std::cout << b.to_string().c_str() << std::endl;
   std::cout << b.to_string('1', 'X').c_str() << std::endl;

  /*
  сдвиг влево <<, x << y это равносильно умножению x * 2^y 
  сдвиг вправо >>, x >> y, наоборот эквивалентно делению x / 2^y, прошу заметить что деление целочисленное 
  если один из операндов битового сдвига отрицательное число то это неопределенное поведение -1 << 1
  */
   std::cout << (5 << 1) << std::endl;
   std::cout << (4 << 2) << std::endl;

   std::cout << (8 >> 1) << std::endl;

   // этой конструкцией мы проверяем что установлен ли бит
   // также эта конструкция проверяет четное число или нет
   bool is_set = (value & 1);
   return 0;
}
```
При сдвиге в право и сдвиге влево, операнды не должны быть негативными
Сдвиг влево <<, x << y это равносильно умножению x * 2^y 
Сдвиг вправо >>, x >> y, наоборот эквивалентно делению x / 2^y, прошу заметить что все деление целочисленное
Также битовые операторы & и | могут применяються и с операторами отношения, разница между логическими в том что в таком случае будут выполняться/проверяться оба операнда.
Также битовые операции могут быть и составными(например >>= и т.д.)
Битовая арифметика применима только к целым числам и в основном к беззнаковым, компилятор выдаст ошибку при попытке применить один из битовых операций к вещественному числу.
Отдельной темой являееться битовая операция исключающее или, она часто применяеться в криптографии для шифрации и дешифрации, для генерации случайных чисел и т.д. Но это пока выходит за рамки нашего с вами курса).
Также есть такое понятия как порядок байтов, т.е как представляються байты от младшего к старшему. На компьютере представляються как порядок от младшего к старшему(little-endian), а в сетевой архитекруте как от большого к младшему(big-endian). Для преобразования служит функции htol.. Т.е. преобразование между сетевым представлением числа в компьютерный.

### Операции применимы к типу char
отдельной темой я хотел бы написать это про применение  некоторых арифметических операций к типу char. Исторически так сложилось что тип char, на большинстве платформ, есть найменший тип данных 1 байт, и его применяли в языке С и С++ для работы с целыми числами, но также и использовали его для текствой информации
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
    char ch = 65;
    std::cout << (unsigned)ch << ch << std::endl;

    ++ch;
    std::cout << (unsigned)ch << ch << std::endl;

    ++ch;
    std::cout << (unsigned)ch << ch << std::endl;

    --ch;
    std::cout << (unsigned)ch << ch << std::endl;

    ch = (ch - 1) + 25;
    std::cout << (unsigned)ch << ch << std::endl;
    return 0;
}
```

### Оператор остаток от деления %
Отнситься к арифметическим операциям. Суть его простая, если целое число делиться без остатка то получим ноль, т.е. получаеться деления нацело например 10 поделить на 2 дает нам деление без остатка, а вот 9 уже нацело не делиться без остатка, т.е. грубым словом берем найбольшую часть делимого вообщем ищем найближнее делимое от 9. В нашем примере если 9 на 2 то ближайше делимое это 8 а остаток 1(это грубый пример)

https://naobumium.info/arifmetika/delenie2.php

Другой пример остаток от деления представляют как часовую стрелку, т.е. например
Берем в качестве делителя 12, и любой делимый будет попадать в эту часовой диапазон, как у нас 24 часа).
Ярким пример использования остатка от деления есть проверка числа на четное не четное. Вторым примером это разбиение числа на цифры, или получение последней цифры в числе, еще это перевод десятичного в двоичный формат
При работе с отрицательными числами поведение программы не определено
